#### [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)

> Ⅰ.数组
>
> - 执行用时：49 ms, 在所有 Java 提交中击败了15.48%的用户

```java
class MyHashMap {
    private int[] map;
    /** Initialize your data structure here. */
    public MyHashMap() {
        map = new int[1000001];
        Arrays.fill(map, -1);
    }
    
    /** value will always be non-negative. */
    public void put(int key, int value) {
        map[key] = value;
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    public int get(int key) {
        return map[key];
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    public void remove(int key) {
        map[key] = -1;
    }
}
```

> Ⅱ.拉链法
>
> - 执行用时：19 ms, 在所有 Java 提交中击败了88.49%的用户

```java
class MyHashMap {
    static class Node{
        int key;
        int value;
        Node next;
        Node(int _key, int _value){
            key = _key;
            value = _value;
        }
    }
    Node[] nodes;
    public MyHashMap() {
        // 由于使用的是「链表」，这个值可以取得很小
       nodes = new Node[10009];
    }
    
    public void put(int key, int value) {
         // 根据 key 获取哈希桶的位置
        int index = getIndex(key);
        // 判断链表中是否已经存在
        Node loc = nodes[index];
        Node temp = loc;
        if(loc != null){
            Node pre = null;
            while(temp != null){
                if(temp.key == key){
                    temp.value = value;
                    return;
                }
                pre = temp;
                temp = temp.next;
            }
            // 如果拉链中没有此key，此时temp 为 null， 回退
            temp = pre;
        }
        Node node = new Node(key, value);
        // 头插法
        // node.next = nodes[index];
        // nodes[index] = node;
        // 尾插法
        if(temp != null){
            temp.next = node;
        }else{
            nodes[index] = node;
        }
    }
    
    public int get(int key) {
        int index = getIndex(key);
        Node loc = nodes[index];
        if(loc != null){
            while(loc != null){
                if(loc.key == key){
                    return loc.value;
                }
                loc = loc.next;
            }
        }
        return -1;
    }
    
    public void remove(int key) {
        int index = getIndex(key);
        Node loc = nodes[index];
        if(loc != null){
            Node pre = null;
            while(loc != null){
                if(loc.key == key){
                    if(pre != null){
                        pre.next = loc.next;
                    }else{
                        nodes[index] = loc.next;
                    }
                    return;
                }
                pre = loc;
                loc = loc.next;
            }
        }
    }

    private int getIndex(int key){
        // 因为 nodes 的长度只有 10009，对应的十进制的 10011100011001（总长度为 32 位，其余高位都是 0）
        // 为了让 key 对应的 hash 高位也参与运算，这里对 hashCode 进行右移异或
        // 使得 hashCode 的高位随机性和低位随机性都能体现在低 16 位中
        int hash = Integer.hashCode(key);
        hash  = hash ^ (hash >>> 16);
        return hash % nodes.length;
    }
}

```



```java
// JDK 8 
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

