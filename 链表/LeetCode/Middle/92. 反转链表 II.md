[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

> - 时间击败100%
> - 思路是`m == 1`就是反转链表Ⅰ
> - 否则就是记录要反转前的一个节点，和反转末的节点，记录位置，链表分为三段拼接

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(head == null || head.next == null || m == n){
            return head;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        ListNode curr = head;
        for(int i = 1; i < m; i++){
            prev = curr;
            curr = curr.next;
        }
        ListNode flag = prev;
        ListNode flag2= curr;

        prev = curr;
        curr = curr.next;
        int cnt = n - m;
        while(curr != null && cnt > 0){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
            cnt--;
        }
        flag.next = prev;
        flag2.next = curr;

        return m == 1 ? prev : head;
    }
}
```

---

正儿八经解法：

> - 头插法
> - 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(head == null || head.next == null || m == n){
            return head;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        for(int i = 1; i < m; i++){
            prev = prev.next;
    }
        ListNode curr = prev.next;

        for(int i = m; i < n; i++){
            ListNode next = curr.next;
            curr.next = next.next;
            next.next = prev.next;
            prev.next = next;
        }
        return dummy.next;
}
}
```

> - 递归
> - 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    ListNode successsor = null;
    public ListNode reverseBetween(ListNode head, int m, int n) {
        //base case
        if(m == 1){
            return reverseN(head,n);
        }
        head.next = reverseBetween(head.next,m - 1, n - 1);
        return head;
    }
    private ListNode reverseN(ListNode head ,int n){
        if(n == 1){
            successsor = head.next;
            return head;
        }
        ListNode last = reverseN(head.next,n - 1);
        head.next.next = head;
        head.next = successsor;
        return last;
    }
}
```

